(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{542:function(t,e,a){"use strict";a.r(e);var r=a(26),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"流控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流控"}},[t._v("#")]),t._v(" 流控")]),t._v(" "),e("p",[t._v("本文介绍"),e("a",{attrs:{href:"https://github.com/sermant-io/Sermant/tree/develop/sermant-plugins/sermant-flowcontrol",target:"_blank",rel:"noopener noreferrer"}},[t._v("流控插件"),e("OutboundLink")],1),t._v("及其使用方式。")]),t._v(" "),e("h2",{attrs:{id:"功能介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#功能介绍"}},[t._v("#")]),t._v(" 功能介绍")]),t._v(" "),e("p",[t._v("流控插件基于"),e("a",{attrs:{href:"https://github.com/resilience4j",target:"_blank",rel:"noopener noreferrer"}},[t._v("resilience4j"),e("OutboundLink")],1),t._v(' 框架实现，以"流量"为切入点，实现"非侵入式"流量控制；当前支持'),e("a",{attrs:{href:"#%E9%99%90%E6%B5%81"}},[t._v("限流")]),t._v("、"),e("a",{attrs:{href:"#%E7%86%94%E6%96%AD"}},[t._v("熔断")]),t._v("、"),e("a",{attrs:{href:"#%E9%9A%94%E7%A6%BB"}},[t._v("隔离")]),t._v("、"),e("a",{attrs:{href:"#%E9%94%99%E8%AF%AF%E6%B3%A8%E5%85%A5"}},[t._v("错误注入")]),t._v("、"),e("a",{attrs:{href:"#%E9%87%8D%E8%AF%95"}},[t._v("重试")]),t._v("、"),e("a",{attrs:{href:"#%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%B5%81%E6%8E%A7"}},[t._v("系统规则")]),t._v("，并且支持通过配置中心动态下发流控规则，实时生效。")]),t._v(" "),e("h3",{attrs:{id:"快速开始"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快速开始"}},[t._v("#")]),t._v(" 快速开始")]),t._v(" "),e("p",[t._v("本插件的快速上手使用教程可参考"),e("a",{attrs:{href:"#%E6%93%8D%E4%BD%9C%E5%92%8C%E7%BB%93%E6%9E%9C%E9%AA%8C%E8%AF%81"}},[t._v("操作和结果验证")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"流控功能使用示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流控功能使用示例"}},[t._v("#")]),t._v(" 流控功能使用示例")]),t._v(" "),e("h3",{attrs:{id:"限流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#限流"}},[t._v("#")]),t._v(" 限流")]),t._v(" "),e("p",[e("strong",[t._v("限流能力对指定接口限制1S秒内通过的QPS，当1S内流量超过指定阈值，将触发限流，限制请求流量，在客户端和服务端都可生效。")])]),t._v(" "),e("p",[t._v("执行限流策略需要通过配置中心下发流量匹配规则和限流规则，主要分为两步：")]),t._v(" "),e("p",[e("strong",[t._v("下发流量匹配规则：")]),t._v(" 下发流量匹配规则匹配满足要求的流量。")]),t._v(" "),e("p",[e("strong",[t._v("下发限流规则：")]),t._v(" 下发限流规则对匹配的流量执行限流策略。")]),t._v(" "),e("h4",{attrs:{id:"示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("现有如下场景：在名称为flowcontrol的微服务中，对于API访问路径为/rateLimiting的流量，如果每秒请求数超过2次，将触发限流机制。具体下发的规则如下所示：")]),t._v(" "),e("h5",{attrs:{id:"下发流量匹配规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发流量匹配规则"}},[t._v("#")]),t._v(" 下发流量匹配规则")]),t._v(" "),e("p",[t._v("为实现上述限流场景，首先下发流量匹配规则来匹配需要执行限流策略的流量。根据动态配置中心的配置模型，流量匹配规则由group、key和content组成，group用来约束流量匹配规则生效的微服务，key用来约束流量匹配规则生效的场景，content为具体的流量匹配规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.matchGroup.rateLimitingScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 精确匹配api访问路径为/rateLimiting的流量")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /rateLimiting     \n")])])]),e("p",[t._v("流量匹配的更多规则说明请参考"),e("a",{attrs:{href:"#%E6%B5%81%E9%87%8F%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("流量匹配规则说明")]),t._v("，\n动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：流量匹配规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：流量匹配规则的key由前缀"),e("code",[t._v("servicecomb.matchGroup")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("rateLimitingScene")]),t._v("。流量匹配规则和限流规则的key的自定义场景名称需保持一致，才能对匹配的流量执行限流策略。")])]),t._v(" "),e("h5",{attrs:{id:"下发限流规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发限流规则"}},[t._v("#")]),t._v(" 下发限流规则")]),t._v(" "),e("p",[t._v("下发流量匹配规则后，对匹配的流量执行限流策略还需要下发限流规则。根据动态配置中心的配置模型，限流规则由group、key和content三部分组成，group用来约束限流规则生效的微服务，key用来约束限流规则生效的场景，需和流量匹配规则的场景名称保持一致，content为具体的限流规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.rateLimiting.rateLimitingScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1秒内超过2个请求，则触发限流能力")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("limitRefreshPeriod")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("    \n")])])]),e("p",[t._v("限流配置的更多规则说明请参考"),e("a",{attrs:{href:"#%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("限流规则说明")]),t._v("，动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：限流规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：限流规则的key由前缀"),e("code",[t._v("servicecomb.rateLimiting")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("rateLimitingScene")]),t._v("。流量匹配规则和限流规则的key的自定义场景名称需保持一致，才能对匹配的流量执行限流策略。")])]),t._v(" "),e("h3",{attrs:{id:"熔断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#熔断"}},[t._v("#")]),t._v(" 熔断")]),t._v(" "),e("p",[e("strong",[t._v("熔断指对指定接口配置熔断策略，可从单位统计时间窗口内的错误率或者慢请求率进行统计，当请求错误率或者慢请求率达到指定比例阈值，即触发熔断，在时间窗口重置前，隔离所有请求，在客户端和服务端都可生效。")])]),t._v(" "),e("p",[t._v("执行熔断策略需要通过配置中心下发流量匹配规则和熔断规则，主要分为两步：")]),t._v(" "),e("p",[e("strong",[t._v("下发流量匹配规则：")]),t._v(" 下发流量匹配规则匹配满足要求的流量。")]),t._v(" "),e("p",[e("strong",[t._v("下发熔断规则：")]),t._v(" 下发熔断规则对匹配的流量执行熔断策略。")]),t._v(" "),e("h4",{attrs:{id:"示例-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-2"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("现有如下场景：在名称为flowcontrol的微服务中，对api访问路径为/circuitBreaker的流量，在10秒内，若流量标记的接口请求次数超过3次，且错误率超过90%或者慢请求占比超过80%则触发熔断。具体下发的规则如下所示：")]),t._v(" "),e("h5",{attrs:{id:"下发流量匹配规则-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发流量匹配规则-2"}},[t._v("#")]),t._v(" 下发流量匹配规则")]),t._v(" "),e("p",[t._v("为实现上述熔断场景，首先下发流量匹配规则来匹配需要执行熔断策略的流量。根据动态配置中心的配置模型，流量匹配规则由group、key和content组成，group用来约束流量匹配规则生效的微服务，key用来约束流量匹配规则生效的场景，content为具体的流量匹配规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.matchGroup.circuitBreakerScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 精确匹配api访问路径为/circuitBreaker的流量")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /circuitBreaker     \n")])])]),e("p",[t._v("流量匹配的更多规则说明请参考"),e("a",{attrs:{href:"#%E6%B5%81%E9%87%8F%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("流量匹配规则说明")]),t._v("，\n动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：流量匹配规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：流量匹配规则的key由前缀"),e("code",[t._v("servicecomb.matchGroup")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("circuitBreakerScene")]),t._v("。流量匹配规则和熔断规则的key的自定义场景名称需保持一致，才能对匹配的流量执行熔断策略。")])]),t._v(" "),e("h5",{attrs:{id:"下发熔断规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发熔断规则"}},[t._v("#")]),t._v(" 下发熔断规则")]),t._v(" "),e("p",[t._v("下发流量匹配规则后，对匹配的流量执行熔断策略还需要下发熔断规则。根据动态配置中心的配置模型，熔断规则由group、key和content三部分组成，group用来约束熔断规则生效的微服务，key用来约束熔断规则生效的场景，需和流量匹配规则的场景名称保持一致，content为具体的熔断规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.circuitBreaker.circuitBreakerScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 在10秒内，若流量标记的接口请求次数超过3次，且错误率超过90%或者慢请求占比超过80%则触发熔断")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("failureRateThreshold")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("90")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("minimumNumberOfCalls")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("slidingWindowSize")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 10S\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("slidingWindowType")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" time\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("slowCallRateThreshold")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),t._v("  \n")])])]),e("p",[t._v("熔断配置的更多规则说明请参考"),e("a",{attrs:{href:"#%E7%86%94%E6%96%AD%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("熔断规则说明")]),t._v("，动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：熔断规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：熔断规则的key由前缀"),e("code",[t._v("servicecomb.circuitBreaker")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("circuitBreakerScene")]),t._v("。流量匹配规则和熔断规则的key的自定义场景名称需保持一致，才能对匹配的流量执行熔断策略。")])]),t._v(" "),e("h4",{attrs:{id:"熔断指标采集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#熔断指标采集"}},[t._v("#")]),t._v(" 熔断指标采集")]),t._v(" "),e("p",[t._v("服务配置了"),e("a",{attrs:{href:"#%E7%86%94%E6%96%AD"}},[t._v("熔断策略")]),t._v("后，可以开启监控开关，插件会异步采集"),e("RouterLink",{attrs:{to:"/zh/document/plugin/monitor.html#熔断指标"}},[t._v("熔断指标")]),t._v("，并通过"),e("RouterLink",{attrs:{to:"/zh/document/plugin/monitor.html"}},[t._v("监控插件")]),t._v("进行指标上报。\n在"),e("code",[t._v("${sermant-path}/agent/pluginPackage/flowcontrol/config/config.yaml")]),t._v("配置文件中开启监控开关：")],1),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("flow.control.plugin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enable-start-monitor")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v(" \n")])])]),e("blockquote",[e("p",[t._v("说明：${sermant-path}为sermant包路径。")])]),t._v(" "),e("h3",{attrs:{id:"隔离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#隔离"}},[t._v("#")]),t._v(" 隔离")]),t._v(" "),e("p",[e("strong",[t._v("隔离对指定接口设置允许的最大并发量，当超过最大并发量时，对并发流量进行排队等待控制，等待超过最大等待时间则拒绝调用，避免瞬时并发流量过大导致服务崩溃，在客户端和服务端都可生效。")])]),t._v(" "),e("p",[t._v("执行隔离策略需要通过配置中心下发流量匹配规则和限流规则，主要分为两步：")]),t._v(" "),e("p",[e("strong",[t._v("下发流量匹配规则：")]),t._v(" 下发流量匹配规则匹配满足要求的流量。")]),t._v(" "),e("p",[e("strong",[t._v("下发隔离规则：")]),t._v(" 下发隔离规则对匹配的流量执行隔离策略。")]),t._v(" "),e("h4",{attrs:{id:"示例-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-3"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("现有如下场景：在名称为flowcontrol的微服务中，对api访问路径为/bulkhead的流量，若最大并发数超过5，且新的请求等待10S，还未获取资源，则触发隔离异常。")]),t._v(" "),e("h5",{attrs:{id:"下发流量匹配规则-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发流量匹配规则-3"}},[t._v("#")]),t._v(" 下发流量匹配规则")]),t._v(" "),e("p",[t._v("为实现上述隔离场景，首先下发流量匹配规则来匹配需要执行隔离策略的流量。根据动态配置中心的配置模型，流量匹配规则由group、key和content组成，group用来约束流量匹配规则生效的微服务，key用来约束流量匹配规则生效的场景，content为具体的流量匹配规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.matchGroup.bulkheadScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 精确匹配api访问路径为/bulkhead的流量")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /bulkhead     \n")])])]),e("p",[t._v("流量匹配的更多规则说明请参考"),e("a",{attrs:{href:"#%E6%B5%81%E9%87%8F%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("流量匹配规则说明")]),t._v("，动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：流量匹配规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：流量匹配规则的key由前缀"),e("code",[t._v("servicecomb.matchGroup")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("bulkheadScene")]),t._v("。流量匹配规则和隔离规则的key的自定义场景名称需保持一致，才能对匹配的流量执行隔离策略。")])]),t._v(" "),e("h5",{attrs:{id:"下发隔离规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发隔离规则"}},[t._v("#")]),t._v(" 下发隔离规则")]),t._v(" "),e("p",[t._v("下发流量匹配规则后，对匹配的流量执行隔离策略还需要下发隔离规则。根据动态配置中心的配置模型，隔离规则由group、key和content三部分组成，group用来约束隔离规则生效的微服务，key用来约束隔离规则生效的场景，需和流量匹配规则的场景名称保持一致，content为具体的隔离规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontroll")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.bulkhead.bulkheadScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 最大并发数超过5，且新的请求等待10S，还未获取资源，则触发隔离异常")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("maxConcurrentCalls")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("maxWaitDuration")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 10S\n")])])]),e("p",[t._v("隔离配置的更多规则说明请参考"),e("a",{attrs:{href:"#%E9%9A%94%E7%A6%BB%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("隔离规则说明")]),t._v("，动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：隔离规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：隔离规则的key由前缀"),e("code",[t._v("servicecomb.bulkhead")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("bulkheadScene")]),t._v("。流量匹配规则和隔离规则的key的自定义场景名称需保持一致，才能对匹配的流量执行隔离策略。")])]),t._v(" "),e("h3",{attrs:{id:"错误注入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误注入"}},[t._v("#")]),t._v(" 错误注入")]),t._v(" "),e("p",[e("strong",[t._v("错误注入指在服务运行时，给指定服务配置错误注入策略，在客户端访问目标服务前，以指定策略模式返回。该策略多用于减少目标服务的访问负载，可作为降级的一种措施。")])]),t._v(" "),e("p",[t._v("执行错误注入策略需要通过配置中心下发流量匹配规则和限流规则，主要分为两步：")]),t._v(" "),e("p",[e("strong",[t._v("下发流量匹配规则：")]),t._v(" 下发流量匹配规则匹配满足要求的流量。")]),t._v(" "),e("p",[e("strong",[t._v("下发错误注入规则：")]),t._v(" 下发错误注入规则对匹配的流量执行错误注入策略。")]),t._v(" "),e("h4",{attrs:{id:"示例-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-4"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("现有如下场景：在名称为flowcontrol的微服务中，对api访问路径为/faultInjection的流量，访问接口时100%将返回空值。")]),t._v(" "),e("h5",{attrs:{id:"下发流量匹配规则-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发流量匹配规则-4"}},[t._v("#")]),t._v(" 下发流量匹配规则")]),t._v(" "),e("p",[t._v("为实现上述错误注入场景，首先下发流量匹配规则来匹配需要执行错误注入策略的流量。根据动态配置中心的配置模型，流量匹配规则由group、key和content组成，group用来约束流量匹配规则生效的微服务，key用来约束流量匹配规则生效的场景，content为具体的流量匹配规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.matchGroup.faultInjectionScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 精确匹配api访问路径为/faultInjection的流量")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /faultInjection     \n")])])]),e("p",[t._v("流量匹配的更多规则说明请参考"),e("a",{attrs:{href:"#%E6%B5%81%E9%87%8F%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("流量匹配规则说明")]),t._v("，\n动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：流量匹配规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：流量匹配规则的key由前缀"),e("code",[t._v("servicecomb.matchGroup")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("faultInjectionScene")]),t._v("。流量匹配规则和错误注入规则的key的自定义场景名称需保持一致，才能对匹配的流量执行错误注入策略。")])]),t._v(" "),e("h5",{attrs:{id:"下发错误注入规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发错误注入规则"}},[t._v("#")]),t._v(" 下发错误注入规则")]),t._v(" "),e("p",[t._v("下发流量匹配规则后，对匹配的流量执行错误注入策略还需要下发错误注入规则。根据动态配置中心的配置模型，错误注入规则由group、key和content三部分组成，group用来约束错误注入规则生效的微服务，key用来约束错误注入规则生效的场景，需和流量匹配规则的场景名称保持一致，content为具体的错误注入规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.faultInjection.faultInjectionScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 访问接口时100%将返回空值")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("type")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" abort\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("percentage")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fallbackType")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ReturnNull\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("forceClosed")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("false")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("errorCode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("503")]),t._v("\n")])])]),e("p",[t._v("错误注入配置的更多规则说明请参考"),e("a",{attrs:{href:"#%E9%94%99%E8%AF%AF%E6%B3%A8%E5%85%A5%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("错误注入规则说明")]),t._v("，动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：错误注入规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：错误注入规则的key由前缀"),e("code",[t._v("servicecomb.faultInjection")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("faultInjectionScene")]),t._v("。流量匹配规则和错误注入规则的key的自定义场景名称需保持一致，才能对匹配的流量执行错误注入策略。")])]),t._v(" "),e("h3",{attrs:{id:"重试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重试"}},[t._v("#")]),t._v(" 重试")]),t._v(" "),e("p",[e("strong",[t._v("重试策略指当服务遇到非致命的错误时，可以通过重试的方式避免服务的最终失败。")])]),t._v(" "),e("p",[t._v("执行重试策略需要通过配置中心下发流量匹配规则和限流规则，主要分为两步：")]),t._v(" "),e("p",[e("strong",[t._v("下发流量匹配规则：")]),t._v(" 下发流量匹配规则匹配满足要求的流量。")]),t._v(" "),e("p",[e("strong",[t._v("下发重试规则：")]),t._v(" 下发重试规则对匹配的流量执行重试策略。")]),t._v(" "),e("h4",{attrs:{id:"示例-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-5"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("现有如下场景：在名称为flowcontrol的微服务中，对api访问路径为/retry的流量，访问接口时，当请求抛出500异常时进行重试，直到重试成功或者达到最大重试次数。")]),t._v(" "),e("h5",{attrs:{id:"下发流量匹配规则-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发流量匹配规则-5"}},[t._v("#")]),t._v(" 下发流量匹配规则")]),t._v(" "),e("p",[t._v("为实现上述重试场景，首先下发流量匹配规则来匹配需要执行重试策略的流量。根据动态配置中心的配置模型，流量匹配规则由group、key和content组成，group用来约束流量匹配规则生效的微服务，key用来约束流量匹配规则生效的场景，content为具体的流量匹配规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.matchGroup.retryScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 精确匹配api访问路径为/retry的流量")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /retry     \n")])])]),e("p",[t._v("流量匹配的更多规则说明请参考"),e("a",{attrs:{href:"#%E6%B5%81%E9%87%8F%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("流量匹配规则说明")]),t._v("，\n动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：流量匹配规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：流量匹配规则的key由前缀"),e("code",[t._v("servicecomb.matchGroup")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("retryScene")]),t._v("。流量匹配规则和重试规则的key的自定义场景名称需保持一致，才能对匹配的流量执行重试策略。")])]),t._v(" "),e("h5",{attrs:{id:"下发重试规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发重试规则"}},[t._v("#")]),t._v(" 下发重试规则")]),t._v(" "),e("p",[t._v("下发流量匹配规则后，对匹配的流量执行重试策略还需要下发重试规则。根据动态配置中心的配置模型，重试规则由group、key和content三部分组成，group用来约束重试规则生效的微服务，key用来约束重试规则生效的场景，需和流量匹配规则的场景名称保持一致，content为具体的重试规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.retry.retryScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 访问接口时，当请求抛出500异常时进行重试，直到重试成功或者达到最大重试次数")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("waitDuration")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2000")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("retryStrategy")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" FixedInterval\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("maxAttempts")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("retryOnResponseStatus")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),t._v("\n")])])]),e("p",[t._v("重试配置的更多规则说明请参考"),e("a",{attrs:{href:"#%E9%87%8D%E8%AF%95%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("重试规则说明")]),t._v("，动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：重试规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：重试规则的key由前缀"),e("code",[t._v("servicecomb.retry")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("retryScene")]),t._v("。流量匹配规则和重试规则的key的自定义场景名称需保持一致，才能对匹配的流量执行重试策略。")])]),t._v(" "),e("h3",{attrs:{id:"系统级流控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#系统级流控"}},[t._v("#")]),t._v(" 系统级流控")]),t._v(" "),e("p",[e("strong",[t._v("系统级别的流控策略是指，在服务运行过程中，当系统的负载、CPU使用率、并发线程数、请求的平均响应时间或请求的每秒数量（qps）任何一个指标超过预设阈值时，将会启动流控机制，对请求流量进行限制。")])]),t._v(" "),e("p",[t._v("使用系统级流控能力，需要在"),e("code",[t._v("${sermant-path}/agent/pluginPackage/flowcontrol/config/config.yaml")]),t._v("配置文件中开启系统级流控开关：")]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("flow.control.plugin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enable-system-rule")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v(" \n")])])]),e("blockquote",[e("p",[t._v("说明：${sermant-path}为sermant包路径。")])]),t._v(" "),e("p",[t._v("执行系统规则策略需要通过配置中心下发流量匹配规则和限流规则，主要分为两步：")]),t._v(" "),e("p",[e("strong",[t._v("下发流量匹配规则：")]),t._v(" 下发流量匹配规则匹配满足要求的流量。")]),t._v(" "),e("p",[e("strong",[t._v("下发系统级流控规则：")]),t._v(" 下发系统级流控规则对匹配的流量执行系统级流控策略。")]),t._v(" "),e("h4",{attrs:{id:"示例-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-6"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("现有如下场景：在名称为flowcontrol的微服务中，对api访问路径为/system的流量，当系统负载超过5，或cpu使用率超过0.6，或qps超过1000，或请求响应时间小于100ms，或并发线程数大于200时，即触发限流，返回对应异常信息。")]),t._v(" "),e("h5",{attrs:{id:"下发流量匹配规则-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发流量匹配规则-6"}},[t._v("#")]),t._v(" 下发流量匹配规则")]),t._v(" "),e("p",[t._v("为实现上述系统规则场景，首先下发流量匹配规则来匹配需要执行系统规则策略的流量。根据动态配置中心的配置模型，流量匹配规则由group、key和content组成，group用来约束流量匹配规则生效的微服务，key用来约束流量匹配规则生效的场景，content为具体的流量匹配规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.matchGroup.systemScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 精确匹配api访问路径为/system的流量")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /system     \n")])])]),e("p",[t._v("流量匹配的更多规则说明请参考"),e("a",{attrs:{href:"#%E6%B5%81%E9%87%8F%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("流量匹配规则说明")]),t._v("，\n动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：流量匹配规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：流量匹配规则的key由前缀"),e("code",[t._v("servicecomb.matchGroup")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("systemScene")]),t._v("。流量匹配规则和系统规则的key的自定义场景名称需保持一致，才能对匹配的流量执行系统规则策略。")])]),t._v(" "),e("h5",{attrs:{id:"下发系统级流控规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发系统级流控规则"}},[t._v("#")]),t._v(" 下发系统级流控规则")]),t._v(" "),e("p",[t._v("下发流量匹配规则后，对匹配的流量执行系统规则策略还需要下发系统规则。根据动态配置中心的配置模型，系统规则由group、key和content三部分组成，group用来约束系统规则生效的微服务，key用来约束系统规则生效的场景，需和流量匹配规则的场景名称保持一致，content为具体的系统规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.system.systemScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 当系统负载超过5，或cpu使用率超过0.6，或qps超过1000，或请求响应时间小于100ms，或并发线程数大于200时，即触发限流，返回异常信息")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("systemLoad")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("cpuUsage")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.6")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("qps")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("aveRt")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("threadNum")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),t._v("\n")])])]),e("p",[t._v("系统级流控配置的更多规则说明请参考"),e("a",{attrs:{href:"#%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"}},[t._v("系统级流控规则说明")]),t._v("，动态配置的配置模型请参考[动态配置中心配置模型](../user-guide/configuration-center.\nmd#sermant动态配置中心模型)。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：系统规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：系统规则的key由前缀"),e("code",[t._v("servicecomb.system")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("systemScene")]),t._v("。流量匹配规则和系统规则的key的自定义场景名称需保持一致，才能对匹配的流量执行系统规则策略。")])]),t._v(" "),e("h4",{attrs:{id:"系统自适应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#系统自适应"}},[t._v("#")]),t._v(" 系统自适应")]),t._v(" "),e("p",[e("strong",[t._v("系统自适应指在服务运行时，根据系统当前负载状态，以及过去一段时间内系统数据，对请求进行自适应流控。")])]),t._v(" "),e("p",[t._v("使用系统自适应规则，需要在"),e("code",[t._v("${sermant-path}/agent/pluginPackage/flowcontrol/config/config.yaml")]),t._v("配置文件中开启系统规则开关和系统自适应开关，并下发"),e("a",{attrs:{href:"#%E4%B8%8B%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99"}},[t._v("系统级流控规则")]),t._v("。根据上述下发的系统级流控规则，系统自适应的规则为当系统负载大于5时，若当前并发线程数大于系统容量（系统容量由qps * minRt计算得出），则触发限流：")]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("flow.control.plugin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enable-system-rule")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v(" \n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enable-system-adaptive")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n")])])]),e("blockquote",[e("p",[t._v("说明1：${sermant-path}为sermant包路径。")])]),t._v(" "),e("h3",{attrs:{id:"多流控能力配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多流控能力配置"}},[t._v("#")]),t._v(" 多流控能力配置")]),t._v(" "),e("p",[e("strong",[t._v("上述文档介绍了如何针对单个流控能力进行配置，本节介绍对于匹配的流量如何执行多个流控策略的配置。")])]),t._v(" "),e("p",[t._v("执行多个流控策略需要通过配置中心下发流量匹配规则和流控规则，主要分为两步：")]),t._v(" "),e("p",[e("strong",[t._v("下发流量匹配规则：")]),t._v(" 下发流量匹配规则匹配满足要求的流量。")]),t._v(" "),e("p",[e("strong",[t._v("下发流控规则：")]),t._v(" 下发多个流控规则对匹配的流量执行流控规则策略。")]),t._v(" "),e("h4",{attrs:{id:"示例-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例-7"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("p",[t._v("现有如下场景：在名称为flowcontrol的微服务中，对api访问路径为/mutliCapability的流量，若1秒内超过2个请求，则触发限流能力，或者访问接口时，当请求抛出500异常时进行重试，直到重试成功或者达到最大重试次数。")]),t._v(" "),e("h5",{attrs:{id:"下发流量匹配规则-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发流量匹配规则-7"}},[t._v("#")]),t._v(" 下发流量匹配规则")]),t._v(" "),e("p",[t._v("为实现上述流控策略场景，首先下发流量匹配规则来匹配需要执行流控策略的流量。根据动态配置中心的配置模型，流量匹配规则由group、key和content组成，group用来约束流量匹配规则生效的微服务，key用来约束流量匹配规则生效的场景，content为具体的流量匹配规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.matchGroup.mutliCapabilityScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 精确匹配api访问路径为/mutliCapability的流量")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /mutliCapability     \n")])])]),e("p",[t._v("流量匹配的更多配置规则请参考"),e("a",{attrs:{href:"#%E6%B5%81%E9%87%8F%E5%8C%B9%E9%85%8D%E9%85%8D%E7%BD%AE%E9%A1%B9"}},[t._v("流量匹配配置项")]),t._v("，\n动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：流量匹配规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：流量匹配规则的key由前缀"),e("code",[t._v("servicecomb.matchGroup")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("mutliCapabilityScene")]),t._v("。流量匹配规则和多个流控规则的key的自定义场景名称需保持一致，才能对匹配的流量执行多个流控策略。")])]),t._v(" "),e("h5",{attrs:{id:"下发限流规则-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发限流规则-2"}},[t._v("#")]),t._v(" 下发限流规则")]),t._v(" "),e("p",[t._v("下发流量匹配规则后，对匹配的流量执行限流策略还需要下发限流规则。根据动态配置中心的配置模型，限流规则由group、key和content三部分组成，group用来约束限流规则生效的微服务，key用来约束限流规则生效的场景，需和流量匹配规则的场景名称保持一致，content为具体的限流规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.rateLimiting.mutliCapabilityScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1秒内超过2个请求，则触发限流能力")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("limitRefreshPeriod")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("    \n")])])]),e("p",[t._v("限流配置的更多配置规则请参考"),e("a",{attrs:{href:"#%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE%E9%A1%B9"}},[t._v("限流策略配置项")]),t._v("一节，动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：限流规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：限流规则的key由前缀"),e("code",[t._v("servicecomb.rateLimiting")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("mutliCapabilityScene")]),t._v("。流量匹配规则和限流规则的key的自定义场景名称需保持一致，才能对匹配的流量执行限流策略。")])]),t._v(" "),e("h5",{attrs:{id:"下发重试规则-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#下发重试规则-2"}},[t._v("#")]),t._v(" 下发重试规则")]),t._v(" "),e("p",[t._v("下发流量匹配规则后，对匹配的流量执行重试策略还需要下发重试规则。根据动态配置中心的配置模型，重试规则由group、key和content三部分组成，group用来约束重试规则生效的微服务，key用来约束重试规则生效的场景，需和流量匹配规则的场景名称保持一致，content为具体的重试规则，其内容如下所示：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=flowcontrol")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.retry.mutliCapabilityScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 访问接口时，当请求抛出500异常时进行重试，直到重试成功或者达到最大重试次数")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("waitDuration")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2000")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("retryStrategy")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" FixedInterval\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("maxAttempts")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("retryOnResponseStatus")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),t._v("\n")])])]),e("p",[t._v("重试配置的更多配置规则请参考"),e("a",{attrs:{href:"#%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE%E9%A1%B9"}},[t._v("重试策略配置项")]),t._v("，动态配置的配置模型请参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心配置模型")]),t._v("。如何使用不同的动态配置中心请参考："),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-zookeeper-的配置模型实现"}},[t._v("基于-zookeeper-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-nacos-的配置模型实现"}},[t._v("基于-nacos-的配置模型实现")]),t._v("，"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#基于-servicecomb-kie-的配置模型实现"}},[t._v("基于-servicecomb-kie-的配置模型实现")]),t._v("。")],1),t._v(" "),e("blockquote",[e("p",[t._v("说明1：重试规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，由微服务配置文件的"),e("code",[t._v("dubbo.application.name")]),t._v("、"),e("code",[t._v("spring.applicaton.name")]),t._v("或"),e("code",[t._v("application")]),t._v("确定，优先级"),e("code",[t._v("dubbo.application.name")]),t._v(" > "),e("code",[t._v("spring.applicaton.name")]),t._v(" > "),e("code",[t._v("application")]),t._v("，本示例设定微服务名称为flowcontrol。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：重试规则的key由前缀"),e("code",[t._v("servicecomb.retry")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("mutliCapabilityScene")]),t._v("。流量匹配规则和重试规则的key的自定义场景名称需保持一致，才能对匹配的流量执行重试策略。")])]),t._v(" "),e("h2",{attrs:{id:"详细规则说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#详细规则说明"}},[t._v("#")]),t._v(" 详细规则说明")]),t._v(" "),e("h3",{attrs:{id:"流量匹配规则说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流量匹配规则说明"}},[t._v("#")]),t._v(" 流量匹配规则说明")]),t._v(" "),e("p",[t._v("流量匹配是使用流控能力的前提配置，用于给不同的流控能力匹配相应的流量。\n流量匹配规则的详细说明如下所示：")]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 匹配器集合，可配置多个")]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 匹配的api路径， 支持各种比较方式，相等(exact)、包含(contains)等            ")]),t._v("\n "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n     "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 具体匹配路径          ")]),t._v("\n     "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /degrade \n   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 请求头")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("headers")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("          \n     "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("key")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n       "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 请求头值，此处为key=value")]),t._v("\n       "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" value  \n   "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("method")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 支持方法类型           ")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" GET\n   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 可选，自定义配置名")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" degrade     \n")])])]),e("p",[t._v("该示例流量匹配规则用于匹配api路径为/degrade，请求头包含exact=value，请求方法类型为get的流量。")]),t._v(" "),e("p",[e("strong",[t._v("流量标记请求路径（apiPath）规则说明")])]),t._v(" "),e("p",[t._v("流量标记的请求路径会因不同的请求协议配置而存在差异，当前主要为Http（Spring）与Rpc（Dubbo）协议，下面分别说明两种请求协议的规则配置方式：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Http协议")]),t._v(" "),e("p",[t._v("该协议依据请求路径进行匹配，例如请求路径为localhost:8080/test/flow，则实际拿到的路径为"),e("code",[t._v("/test/flow")]),t._v("，因此若需设置匹配规则，需依据该路径进行配置。")]),t._v(" "),e("p",[t._v("值得注意的是，如果用户配置了contextPath，则需要加上contextPath前缀才可生效，即流量标记中请求路径为"),e("code",[t._v("${contextPath}/test/flow")]),t._v("。")])]),t._v(" "),e("li",[e("p",[t._v("Rpc协议（Dubbo）")]),t._v(" "),e("p",[t._v("该协议调用需要基于接口+方法，例如请求的接口为com.demo.test，其方法为flow， 则对应的请求路径为"),e("code",[t._v("com.demo.test.flow")]),t._v("，特别的，如果用户有配置接口的版本，例如指定的version为1.0.0， 则请求路径为"),e("code",[t._v("com.demo.test:1.0.0.flow")]),t._v("。同时需要配置请求方法为"),e("code",[t._v("POST")]),t._v("，RPC协议仅支持POST类型。")])])]),t._v(" "),e("h3",{attrs:{id:"限流规则说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#限流规则说明"}},[t._v("#")]),t._v(" 限流规则说明")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("规则项")]),t._v(" "),e("th",[t._v("说明")]),t._v(" "),e("th",[t._v("默认值")]),t._v(" "),e("th",[t._v("是否必须")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("limitRefreshPeriod")]),t._v(" "),e("td",[t._v("单位统计时间，单位毫秒，若需配置秒则可增加单位"),e("code",[t._v("S")]),t._v("， 例如"),e("code",[t._v("10S")])]),t._v(" "),e("td",[t._v("1000ms")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("rate")]),t._v(" "),e("td",[t._v("单位统计时间所能通过的"),e("strong",[t._v("请求个数")])]),t._v(" "),e("td",[t._v("1000")]),t._v(" "),e("td",[t._v("否")])])])]),t._v(" "),e("h3",{attrs:{id:"熔断规则说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#熔断规则说明"}},[t._v("#")]),t._v(" 熔断规则说明")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("规则项")]),t._v(" "),e("th",[t._v("说明")]),t._v(" "),e("th",[t._v("默认值")]),t._v(" "),e("th",[t._v("是否必须")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("failureRateThreshold")]),t._v(" "),e("td",[t._v("熔断所需达到的错误率")]),t._v(" "),e("td",[t._v("50")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("minimumNumberOfCalls")]),t._v(" "),e("td",[t._v("滑动窗口内的最小请求数， 超过最小请求数才开始判断熔断条件")]),t._v(" "),e("td",[t._v("100")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("name")]),t._v(" "),e("td",[t._v("配置项名称，可选参数")]),t._v(" "),e("td",[t._v("null")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("slidingWindowSize")]),t._v(" "),e("td",[t._v("滑动统计窗口大小，支持毫秒与秒，例如"),e("code",[t._v("1000")]),t._v("为1000毫秒，"),e("code",[t._v("10S")]),t._v("代表10秒")]),t._v(" "),e("td",[t._v("100ms")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("slidingWindowType")]),t._v(" "),e("td",[t._v("滑动窗口类型，目前支持"),e("code",[t._v("time")]),t._v("与"),e("code",[t._v("count")]),t._v("两种类型，前者基于时间窗口统计，后者基于请求次数")]),t._v(" "),e("td",[t._v("time")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("slowCallDurationThreshold")]),t._v(" "),e("td",[t._v("慢请求阈值，单位同滑动窗口配置")]),t._v(" "),e("td",[t._v("60s")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("slowCallRateThreshold")]),t._v(" "),e("td",[t._v("慢请求占比，当慢调用请求数达到该比例触发通断")]),t._v(" "),e("td",[t._v("100")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("waitDurationInOpenState")]),t._v(" "),e("td",[t._v("熔断后恢复时间")]),t._v(" "),e("td",[t._v("60s")]),t._v(" "),e("td",[t._v("否")])])])]),t._v(" "),e("h3",{attrs:{id:"隔离规则说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#隔离规则说明"}},[t._v("#")]),t._v(" 隔离规则说明")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("规则项")]),t._v(" "),e("th",[t._v("说明")]),t._v(" "),e("th",[t._v("默认值")]),t._v(" "),e("th",[t._v("是否必须")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("maxConcurrentCalls")]),t._v(" "),e("td",[t._v("最大并发数")]),t._v(" "),e("td",[t._v("1000")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("maxWaitDuration")]),t._v(" "),e("td",[t._v("最大等待时间，若线程超过"),e("code",[t._v("maxConcurrentCalls")]),t._v("，会尝试等待，若超出等待时间还未获取资源，则抛出隔离仓异常")]),t._v(" "),e("td",[t._v("0")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("name")]),t._v(" "),e("td",[t._v("可选，配置名称")]),t._v(" "),e("td",[t._v("null")]),t._v(" "),e("td",[t._v("否")])])])]),t._v(" "),e("h3",{attrs:{id:"错误注入规则说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误注入规则说明"}},[t._v("#")]),t._v(" 错误注入规则说明")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("规则项")]),t._v(" "),e("th",[t._v("说明")]),t._v(" "),e("th",[t._v("默认值")]),t._v(" "),e("th",[t._v("是否必须")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("type")]),t._v(" "),e("td",[t._v("错误注入类型，目前支持abort(请求直接返回)与delay（请求延时）")]),t._v(" "),e("td",[t._v("delay")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("percentage")]),t._v(" "),e("td",[t._v("错误注入触发概率")]),t._v(" "),e("td",[t._v("-1")]),t._v(" "),e("td",[t._v("是")])]),t._v(" "),e("tr",[e("td",[t._v("fallbackType")]),t._v(" "),e("td",[t._v("请求调用返回类型，仅"),e("code",[t._v("type=abort")]),t._v("生效。当前支持两种"),e("code",[t._v("ReturnNull")]),t._v(":直接返回空内容，状态码200；"),e("code",[t._v("ThrowException")]),t._v(": 按照指定错误码返回，关联配置"),e("code",[t._v("errorCode")])]),t._v(" "),e("td",[t._v("ThrowException")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("errorCode")]),t._v(" "),e("td",[t._v("指定错误码返回，默认500，仅在"),e("code",[t._v("type=abort")]),t._v("且"),e("code",[t._v("fallbackType=ThrowException")]),t._v("生效")]),t._v(" "),e("td",[t._v("500")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("forceClosed")]),t._v(" "),e("td",[t._v("是否强制关闭错误注入能力，当为true时，错误注入将不会生效。默认false")]),t._v(" "),e("td",[t._v("false")]),t._v(" "),e("td",[t._v("否")])])])]),t._v(" "),e("h3",{attrs:{id:"重试规则说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重试规则说明"}},[t._v("#")]),t._v(" 重试规则说明")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("规则项")]),t._v(" "),e("th",[t._v("说明")]),t._v(" "),e("th",[t._v("默认值")]),t._v(" "),e("th",[t._v("是否必须")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("waitDuration")]),t._v(" "),e("td",[t._v("重试等待时间，默认毫秒；支持秒单位，例如2S")]),t._v(" "),e("td",[t._v("10ms")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("retryStrategy")]),t._v(" "),e("td",[t._v("重试策略，当前支持两种重试策略：固定时间间隔（FixedInterval）， 指数增长间隔(RandomBackoff)")]),t._v(" "),e("td",[t._v("FixedInterval")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("maxAttempts")]),t._v(" "),e("td",[t._v("最大重试次数")]),t._v(" "),e("td",[t._v("3")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("retryOnResponseStatus")]),t._v(" "),e("td",[t._v("HTTP状态码，当前仅支持HTTP请求；针对dubbo请求，可通过配置异常类型确定是否需要重试，默认为RpcException")]),t._v(" "),e("td",[t._v("null")]),t._v(" "),e("td",[t._v("否")])])])]),t._v(" "),e("h3",{attrs:{id:"系统级流控规则说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#系统级流控规则说明"}},[t._v("#")]),t._v(" 系统级流控规则说明")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("规则项")]),t._v(" "),e("th",[t._v("说明")]),t._v(" "),e("th",[t._v("默认值")]),t._v(" "),e("th",[t._v("是否必须")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("systemLoad")]),t._v(" "),e("td",[t._v("系统负载阈值，仅支持linux")]),t._v(" "),e("td",[t._v("Double.MAX_VALUE")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("cpuUsage")]),t._v(" "),e("td",[t._v("系统cpu使用率阈值")]),t._v(" "),e("td",[t._v("1.0")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("qps")]),t._v(" "),e("td",[t._v("入口流量的qps阈值")]),t._v(" "),e("td",[t._v("Double.MAX_VALUE")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("aveRt")]),t._v(" "),e("td",[t._v("入口流量的平均响应时间阈值，单位ms")]),t._v(" "),e("td",[t._v("Long.MAX_VALUE")]),t._v(" "),e("td",[t._v("否")])]),t._v(" "),e("tr",[e("td",[t._v("threadNum")]),t._v(" "),e("td",[t._v("入口流量的并发线程数阈值")]),t._v(" "),e("td",[t._v("Long.MAX_VALUE")]),t._v(" "),e("td",[t._v("否")])])])]),t._v(" "),e("h3",{attrs:{id:"基于配置文件设置流控规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于配置文件设置流控规则"}},[t._v("#")]),t._v(" 基于配置文件设置流控规则")]),t._v(" "),e("p",[t._v("若应用未采用配置中心的方式配置流控规则，也可采用配置文件的方式使用流控能力。")]),t._v(" "),e("p",[t._v("流控插件在应用启动时，会尝试从SpringBoot框架加载的配置源读取流控规则，用户需要在启动之前进行配置。如下为流控规则的配置示例，示例配置直接基于"),e("code",[t._v("application.yml")]),t._v("文件进行配置：")]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("servicecomb")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                            \n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matchGroup")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("            \n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 重试场景下的流量匹配规则")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("demo-retry")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                         \n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                          \n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                      \n            "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("prefix")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/retry"')]),t._v("            \n          "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("serviceName")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" rest"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("provider    \n          "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("method")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                       \n          "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" GET\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 限流场景下的流量匹配规则                        ")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("demo-rateLimiting")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                  \n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/flow"')]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rateLimiting")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                         \n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 限流场景下的流控规则")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("demo-rateLimiting")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("retry")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("                                \n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 重试场景下的流控规则")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("demo-retry")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),e("span",{pre:!0,attrs:{class:"token scalar string"}},[t._v("\n      maxAttempts: 3\n      retryOnResponseStatus:\n      - 500")]),t._v("\n")])])]),e("h2",{attrs:{id:"支持版本与限制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#支持版本与限制"}},[t._v("#")]),t._v(" 支持版本与限制")]),t._v(" "),e("h3",{attrs:{id:"支持版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#支持版本"}},[t._v("#")]),t._v(" 支持版本")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("框架类型")]),t._v(" "),e("th",[t._v("版本支持")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("SpringBoot")]),t._v(" "),e("td",[t._v("1.2.x - 2.6.x")])]),t._v(" "),e("tr",[e("td",[t._v("SpringWebMvc")]),t._v(" "),e("td",[t._v("4.1.3.RELEASE - 5.3.x")])]),t._v(" "),e("tr",[e("td",[t._v("Dubbo")]),t._v(" "),e("td",[t._v("2.6.x-2.7.x")])])])]),t._v(" "),e("h3",{attrs:{id:"限制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#限制"}},[t._v("#")]),t._v(" 限制")]),t._v(" "),e("ul",[e("li",[t._v("系统规则与系统自适应规则中"),e("code",[t._v("systemLoad")]),t._v("配置仅限于"),e("strong",[t._v("Linux")]),t._v("。")]),t._v(" "),e("li",[t._v("上述"),e("a",{attrs:{href:"#%E5%9F%BA%E4%BA%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99"}},[t._v("基于配置文件设置配置")]),t._v(" 仅限于"),e("strong",[t._v("Springboot")]),t._v("应用。")])]),t._v(" "),e("h2",{attrs:{id:"操作和结果验证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作和结果验证"}},[t._v("#")]),t._v(" 操作和结果验证")]),t._v(" "),e("p",[t._v("下面我们通过限流场景开始使用流控插件，通过简单的几个步骤，就可以开始对微服务执行限流。本次示例使用ZooKeeper作为动态配置中心。")]),t._v(" "),e("h3",{attrs:{id:"_1-准备工作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-准备工作"}},[t._v("#")]),t._v(" 1 准备工作")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/sermant-io/Sermant-examples/releases/download/v2.0.0/sermant-examples-dynamic-demo-2.0.0.tar.gz",target:"_blank",rel:"noopener noreferrer"}},[t._v("下载"),e("OutboundLink")],1),t._v("流控Demo二进制产物压缩包")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/sermant-io/Sermant/releases/download/v2.0.0/sermant-2.0.0.tar.gz",target:"_blank",rel:"noopener noreferrer"}},[t._v("下载"),e("OutboundLink")],1),t._v("Sermant Release包（当前版本推荐2.0.0版本）")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zookeeper.apache.org/releases#download",target:"_blank",rel:"noopener noreferrer"}},[t._v("下载"),e("OutboundLink")],1),t._v("并启动ZooKeeper")])]),t._v(" "),e("h3",{attrs:{id:"_2-限流示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-限流示例"}},[t._v("#")]),t._v(" 2 限流示例")]),t._v(" "),e("h4",{attrs:{id:"步骤一-启动流控demo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#步骤一-启动流控demo"}},[t._v("#")]),t._v(" 步骤一：启动流控Demo")]),t._v(" "),e("p",[t._v("解压准备工作下载的流控Demo获得可执行JAR包，即spring-provider.jar文件，参考如下命令启动Demo")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#linux mac")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("java")]),t._v(" -javaagent:"),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("${sermant-path}")]),t._v("/agent/sermant-agent.jar "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-Dspring.application.name")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("spring-flow-provider "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-jar")]),t._v(" spring-provider.jar\n")])])]),e("blockquote",[e("p",[e("strong",[t._v("说明：")]),t._v(" ${sermant-path}为Sermant包路径。")])]),t._v(" "),e("h4",{attrs:{id:"步骤二-发布流量匹配规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#步骤二-发布流量匹配规则"}},[t._v("#")]),t._v(" 步骤二：发布流量匹配规则")]),t._v(" "),e("p",[t._v("参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心使用手册配置模型")]),t._v("，流量匹配规则由group、key和content三部分组成，group用来约束流量匹配规则生效的微服务，key用来约束流量匹配规则生效的场景，需和限流规则的场景名称保持一致，content为具体的流量匹配规则，其内容如下所示：")],1),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=spring-flow-provider")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.matchGroup.flowScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 精确匹配api路径为/flow并且请求方法类型为GET的流量")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("matches")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiPath")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("exact")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /flow\n    "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("method")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" GET    \n")])])]),e("blockquote",[e("p",[t._v("说明1：流量匹配规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，本示例所使用Demo的微服务名称为spring-flow-provider。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：流量匹配规则的key由前缀"),e("code",[t._v("servicecomb.matchGroup")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("flowScene")]),t._v("。流量匹配规则和限流规则的key的自定义场景名称需保持一致，才能对匹配的流量执行限流策略。")])]),t._v(" "),e("p",[t._v("利用ZooKeeper提供的命令行工具下发流量匹配规则：")]),t._v(" "),e("ol",[e("li",[t._v("在"),e("code",[t._v("${zookeeper-path}/bin/")]),t._v("目录执行以下命令创建配置模型的group节点"),e("code",[t._v("/service=spring-flow-provider")]),t._v("：")])]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# linux mac")]),t._v("\n./zkCli.sh "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-server")]),t._v(" localhost:2181 create /service"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("spring-flow-provider\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("创建完成group节点后，在"),e("code",[t._v("${zookeeper-path}/bin/")]),t._v("目录执行以下命令创建配置模型的key节点"),e("code",[t._v("/service=spring-flow-provider/servicecomb.matchGroup.flowScene")]),t._v("，并设置节点的content：")])]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# linux mac")]),t._v("\n./zkCli.sh "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-server")]),t._v(" localhost:2181 create /service"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("spring-flow-provider/servicecomb.matchGroup.flowScene "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"matches:\n- apiPath:\n    exact: /flow\n  method:\n  - GET"')]),t._v("\n")])])]),e("blockquote",[e("p",[t._v("说明：${zookeeper-path}为ZooKeeper的安装目录。")])]),t._v(" "),e("h4",{attrs:{id:"步骤三-发布限流规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#步骤三-发布限流规则"}},[t._v("#")]),t._v(" 步骤三：发布限流规则")]),t._v(" "),e("p",[t._v("参考"),e("RouterLink",{attrs:{to:"/zh/document/user-guide/configuration-center.html#sermant动态配置中心模型"}},[t._v("动态配置中心使用手册配置模型")]),t._v("，限流规则由group、key和content三部分组成，group用来约束限流规则生效的微服务，key用来约束限流规则生效的场景，需和流量匹配规则的场景名称保持一致，content为具体的限流规则，其内容如下所示：")],1),t._v(" "),e("ul",[e("li",[e("strong",[t._v("group：")]),t._v(" service=spring-flow-provider")]),t._v(" "),e("li",[e("strong",[t._v("key：")]),t._v(" servicecomb.rateLimiting.flowScene")]),t._v(" "),e("li",[e("strong",[t._v("content：")])])]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 限制两秒内不能访问超过四次")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("limitRefreshPeriod")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 2S\n  "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v("\n")])])]),e("blockquote",[e("p",[t._v("说明1：限流规则的group由"),e("code",[t._v("service=")]),t._v("和"),e("code",[t._v("${service.name}")]),t._v("组成，其中"),e("code",[t._v("${service.name}")]),t._v("为微服务的名称，本示例所使用Demo的微服务名称为spring-flow-provider。")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明2：限流规则的key由前缀"),e("code",[t._v("servicecomb.rateLimiting")]),t._v("和自定义场景名称组成，本示例设定场景名称为"),e("code",[t._v("flowScene")]),t._v("。流量匹配规则和限流规则的key的自定义场景名称需保持一致，才能对匹配的流量执行限流策略。")])]),t._v(" "),e("p",[t._v("利用ZooKeeper提供的命令行工具下发限流规则：")]),t._v(" "),e("ol",[e("li",[t._v("步骤二已经创建了group节点，在"),e("code",[t._v("${zookeeper-path}/bin/")]),t._v("目录执行以下命令创建配置模型的key节点"),e("code",[t._v("/service=spring-flow-provider/servicecomb.rateLimiting.flowScene")]),t._v("并设置节点的content：")])]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# linux mac")]),t._v("\n./zkCli.sh "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-server")]),t._v(" localhost:2181 create /service"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("spring-flow-provider/servicecomb.rateLimiting.flowScene "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"limitRefreshPeriod: 2S\nrate: 4"')]),t._v("\n")])])]),e("blockquote",[e("p",[t._v("说明：${zookeeper-path}为ZooKeeper的安装目录。")])]),t._v(" "),e("h3",{attrs:{id:"_3-验证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-验证"}},[t._v("#")]),t._v(" 3 验证")]),t._v(" "),e("p",[t._v("通过浏览器多次请求"),e("code",[t._v("localhost:8003/flow")]),t._v("若在2秒内请求数超过4个时返回"),e("code",[t._v("rate limited")]),t._v("，则触发流控成功，效果如下：\n"),e("MyImage",{attrs:{src:"/docs-img/flowcontrol-verity.jpg"}})],1)])}),[],!1,null,null,null);e.default=s.exports}}]);